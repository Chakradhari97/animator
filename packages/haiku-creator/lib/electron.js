'use strict';

var _electron = require('electron');

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _util = require('util');

var _Mixpanel = require('haiku-serialization/src/utils/Mixpanel');

var _Mixpanel2 = _interopRequireDefault(_Mixpanel);

var _TopMenu = require('./TopMenu');

var _TopMenu2 = _interopRequireDefault(_TopMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// First-party dependencies
// Third-party dependencies
if (!_electron.app) {
  throw new Error('You can only run electron.js from an electron process');
}

// Local dependencies


_electron.app.setName('Haiku');

_electron.systemPreferences.setUserDefault('NSDisabledDictationMenuItem', 'boolean', true);
_electron.systemPreferences.setUserDefault('NSDisabledCharacterPaletteMenuItem', 'boolean', true);

// See bottom
function CreatorElectron() {
  _events2.default.apply(this);
}
(0, _util.inherits)(CreatorElectron, _events2.default);
var creator = new CreatorElectron();

var appUrl = 'file://' + _path2.default.join(__dirname, '..', 'index.html');

// Plumbing starts up this process, and it uses HAIKU_ENV to forward to us data about
// how it has been set up, e.g. what ports it is using for websocket server, envoy, etc.
// This is sent into the DOM part of the app at did-finish load; see below.
var haiku = global.process.env.HAIKU_ENV ? JSON.parse(global.process.env.HAIKU_ENV) : {};

if (!haiku.folder) {
  haiku.folder = global.process.env.HAIKU_PROJECT_FOLDER;
}

var browserWindow = null;

_electron.app.on('window-all-closed', function () {
  _electron.app.quit();
});

if (!haiku.plumbing) haiku.plumbing = {};

if (!haiku.plumbing.url) {
  if (global.process.env.NODE_ENV !== 'test' && !global.process.env.HAIKU_PLUMBING_PORT) {
    throw new Error('Oops! You must define a HAIKU_PLUMBING_PORT env var!');
  }

  haiku.plumbing.url = 'http://' + (global.process.env.HAIKU_PLUMBING_HOST || '0.0.0.0') + ':' + global.process.env.HAIKU_PLUMBING_PORT + '/';
}

function different(a, b) {
  return a !== b;
}

function createWindow() {
  _Mixpanel2.default.haikuTrack('app:initialize');

  var topmenu = new _TopMenu2.default();

  var menuspec = {
    undoables: [],
    redoables: [],
    projectList: [],
    isSaving: false,
    folder: null
  };

  topmenu.create(menuspec);

  _electron.ipcMain.on('master:heartbeat', function (ipcEvent, masterState) {
    // Update the global menu, but only if the data feeding it appears to have changed.
    // This is driven by a frequent heartbeat hence the reason we are checking for changes
    // before actually re-rendering the whole thing
    var didChange = false;

    // The reason for all these guards is that it appears that the heartbeat either
    // (a) continues to tick despite master crashing
    // (b) returns bad data, missing some fields, when master is in a bad state
    // So we check that the things exist before repopulating
    if (masterState) {
      if (masterState.gitUndoables) {
        if (different(menuspec.undoables.length, masterState.gitUndoables.length)) {
          didChange = true;
          menuspec.undoables = masterState.gitUndoables || [];
        }
      }

      if (masterState.gitRedoables) {
        if (different(menuspec.redoables.length, masterState.gitRedoables.length)) {
          didChange = true;
          menuspec.redoables = masterState.gitRedoables || [];
        }
      }

      if (different(menuspec.folder, masterState.folder)) {
        didChange = true;
        menuspec.folder = masterState.folder;
      }

      if (different(menuspec.isSaving, masterState.isSaving)) {
        didChange = true;
        menuspec.isSaving = masterState.isSaving;
      }
    }

    if (didChange) {
      topmenu.create(menuspec);
    }
  });

  _electron.ipcMain.on('renderer:projects-list-fetched', function (ipcEvent, projectList) {
    menuspec.projectList = projectList;
    topmenu.create(menuspec);
  });

  browserWindow = new _electron.BrowserWindow({
    title: 'Haiku',
    show: false, // Don't show the window until we are ready-to-show (see below)
    titleBarStyle: 'hidden-inset',
    webPreferences: {
      webSecurity: false
    }
  });

  browserWindow.setTitle('Haiku');
  browserWindow.maximize();
  browserWindow.loadURL(appUrl);

  // Sending our haiku configuration into the view so it can correctly set up
  // its own websocket connections to our plumbing server, etc.
  browserWindow.webContents.on('did-finish-load', function () {
    browserWindow.webContents.send('haiku', haiku);
  });

  // TopMenu global-menu:-prefixed events should delegate to BrowserWindow for event handlers.
  var globalMenuPassthroughs = ['check-updates', 'export', 'open-terminal', 'open-text-editor', 'redo', 'save', 'start-tour', 'toggle-dev-tools', 'undo', 'zoom-in', 'zoom-out',
  // Active in dev & staging only.
  'dump-system-info', 'open-hacker-helper'];

  globalMenuPassthroughs.forEach(function (command) {
    topmenu.on('global-menu:' + command, function () {
      var _browserWindow$webCon;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_browserWindow$webCon = browserWindow.webContents).send.apply(_browserWindow$webCon, ['global-menu:' + command].concat(args));
    });
  });

  browserWindow.on('closed', function () {
    browserWindow = null;
  });

  browserWindow.on('ready-to-show', function () {
    browserWindow.show();
  });

  // Uncomment me to automatically open the tools
  // browserWindow.openDevTools()
}

if (_electron.app.isReady()) {
  createWindow();
} else {
  _electron.app.on('ready', createWindow);
}

// Hacky: When plumbing launches inside an Electron process it expects an EventEmitter-like
// object as the export, so we expose this here even though it doesn't do much
module.exports = {
  default: creator
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9lbGVjdHJvbi5qcyJdLCJuYW1lcyI6WyJFcnJvciIsInNldE5hbWUiLCJzZXRVc2VyRGVmYXVsdCIsIkNyZWF0b3JFbGVjdHJvbiIsImFwcGx5IiwiY3JlYXRvciIsImFwcFVybCIsImpvaW4iLCJfX2Rpcm5hbWUiLCJoYWlrdSIsImdsb2JhbCIsInByb2Nlc3MiLCJlbnYiLCJIQUlLVV9FTlYiLCJKU09OIiwicGFyc2UiLCJmb2xkZXIiLCJIQUlLVV9QUk9KRUNUX0ZPTERFUiIsImJyb3dzZXJXaW5kb3ciLCJvbiIsInF1aXQiLCJwbHVtYmluZyIsInVybCIsIk5PREVfRU5WIiwiSEFJS1VfUExVTUJJTkdfUE9SVCIsIkhBSUtVX1BMVU1CSU5HX0hPU1QiLCJkaWZmZXJlbnQiLCJhIiwiYiIsImNyZWF0ZVdpbmRvdyIsImhhaWt1VHJhY2siLCJ0b3BtZW51IiwibWVudXNwZWMiLCJ1bmRvYWJsZXMiLCJyZWRvYWJsZXMiLCJwcm9qZWN0TGlzdCIsImlzU2F2aW5nIiwiY3JlYXRlIiwiaXBjRXZlbnQiLCJtYXN0ZXJTdGF0ZSIsImRpZENoYW5nZSIsImdpdFVuZG9hYmxlcyIsImxlbmd0aCIsImdpdFJlZG9hYmxlcyIsInRpdGxlIiwic2hvdyIsInRpdGxlQmFyU3R5bGUiLCJ3ZWJQcmVmZXJlbmNlcyIsIndlYlNlY3VyaXR5Iiwic2V0VGl0bGUiLCJtYXhpbWl6ZSIsImxvYWRVUkwiLCJ3ZWJDb250ZW50cyIsInNlbmQiLCJnbG9iYWxNZW51UGFzc3Rocm91Z2hzIiwiZm9yRWFjaCIsImNvbW1hbmQiLCJhcmdzIiwiaXNSZWFkeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZhdWx0Il0sIm1hcHBpbmdzIjoiOztBQUNBOztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFHQTs7OztBQUdBOzs7Ozs7QUFKQTtBQU5BO0FBWUEsSUFBSSxjQUFKLEVBQVU7QUFDUixRQUFNLElBQUlBLEtBQUosQ0FBVSx1REFBVixDQUFOO0FBQ0Q7O0FBTEQ7OztBQU9B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RTdCLFFBRjZCLEVBRzdCLGVBSDZCLEVBSTdCLGtCQUo2QixFQUs3QixNQUw2QixFQU03QixNQU42QixFQU83QixZQVA2QixFQVE3QixrQkFSNkIsRUFTN0IsTUFUNkIsRUFVN0IsU0FWNkIsRUFXN0IsVUFYNkI7QUFZN0I7QUFDQSxvQkFiNkIsRUFjN0Isb0JBZDZCLENBQS9COztBQWlCQUEseUJBQXVCQyxPQUF2QixDQUErQixVQUFDQyxPQUFELEVBQWE7QUFDMUN6QixZQUFRWixFQUFSLGtCQUEwQnFDLE9BQTFCLEVBQXFDLFlBQWE7QUFBQTs7QUFBQSx3Q0FBVEMsSUFBUztBQUFUQSxZQUFTO0FBQUE7O0FBQ2hELDZDQUFjTCxXQUFkLEVBQTBCQyxJQUExQixnREFBOENHLE9BQTlDLFNBQTREQyxJQUE1RDtBQUNELEtBRkQ7QUFHRCxHQUpEOztBQU1BdkMsZ0JBQWNDLEVBQWQsQ0FBaUIsUUFBakIsRUFBMkIsWUFBTTtBQUFFRCxvQkFBZ0IsSUFBaEI7QUFBc0IsR0FBekQ7O0FBRUFBLGdCQUFjQyxFQUFkLENBQWlCLGVBQWpCLEVBQWtDLFlBQU07QUFDdENELGtCQUFjMkIsSUFBZDtBQUNELEdBRkQ7O0FBSUE7QUFDQTtBQUNEOztBQUVELElBQUksY0FBSWEsT0FBSixFQUFKLEVBQW1CO0FBQ2pCN0I7QUFDRCxDQUZELE1BRU87QUFDTCxnQkFBSVYsRUFBSixDQUFPLE9BQVAsRUFBZ0JVLFlBQWhCO0FBQ0Q7O0FBRUQ7QUFDQTtBQUNBOEIsT0FBT0MsT0FBUCxHQUFpQjtBQUNmQyxXQUFTeEQ7QUFETSxDQUFqQiIsImZpbGUiOiJlbGVjdHJvbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIFRoaXJkLXBhcnR5IGRlcGVuZGVuY2llc1xuaW1wb3J0IHsgQnJvd3NlcldpbmRvdywgYXBwLCBpcGNNYWluLCBzeXN0ZW1QcmVmZXJlbmNlcyB9IGZyb20gJ2VsZWN0cm9uJ1xuaW1wb3J0IEV2ZW50RW1pdHRlciBmcm9tICdldmVudHMnXG5pbXBvcnQgcGF0aCBmcm9tICdwYXRoJ1xuaW1wb3J0IHsgaW5oZXJpdHMgfSBmcm9tICd1dGlsJ1xuXG4vLyBGaXJzdC1wYXJ0eSBkZXBlbmRlbmNpZXNcbmltcG9ydCBtaXhwYW5lbCBmcm9tICdoYWlrdS1zZXJpYWxpemF0aW9uL3NyYy91dGlscy9NaXhwYW5lbCdcblxuLy8gTG9jYWwgZGVwZW5kZW5jaWVzXG5pbXBvcnQgVG9wTWVudSBmcm9tICcuL1RvcE1lbnUnXG5cbmlmICghYXBwKSB7XG4gIHRocm93IG5ldyBFcnJvcignWW91IGNhbiBvbmx5IHJ1biBlbGVjdHJvbi5qcyBmcm9tIGFuIGVsZWN0cm9uIHByb2Nlc3MnKVxufVxuXG5hcHAuc2V0TmFtZSgnSGFpa3UnKVxuXG5zeXN0ZW1QcmVmZXJlbmNlcy5zZXRVc2VyRGVmYXVsdCgnTlNEaXNhYmxlZERpY3RhdGlvbk1lbnVJdGVtJywgJ2Jvb2xlYW4nLCB0cnVlKVxuc3lzdGVtUHJlZmVyZW5jZXMuc2V0VXNlckRlZmF1bHQoJ05TRGlzYWJsZWRDaGFyYWN0ZXJQYWxldHRlTWVudUl0ZW0nLCAnYm9vbGVhbicsIHRydWUpXG5cbi8vIFNlZSBib3R0b21cbmZ1bmN0aW9uIENyZWF0b3JFbGVjdHJvbiAoKSB7XG4gIEV2ZW50RW1pdHRlci5hcHBseSh0aGlzKVxufVxuaW5oZXJpdHMoQ3JlYXRvckVsZWN0cm9uLCBFdmVudEVtaXR0ZXIpXG5jb25zdCBjcmVhdG9yID0gbmV3IENyZWF0b3JFbGVjdHJvbigpXG5cbmNvbnN0IGFwcFVybCA9ICdmaWxlOi8vJyArIHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICdpbmRleC5odG1sJylcblxuLy8gUGx1bWJpbmcgc3RhcnRzIHVwIHRoaXMgcHJvY2VzcywgYW5kIGl0IHVzZXMgSEFJS1VfRU5WIHRvIGZvcndhcmQgdG8gdXMgZGF0YSBhYm91dFxuLy8gaG93IGl0IGhhcyBiZWVuIHNldCB1cCwgZS5nLiB3aGF0IHBvcnRzIGl0IGlzIHVzaW5nIGZvciB3ZWJzb2NrZXQgc2VydmVyLCBlbnZveSwgZXRjLlxuLy8gVGhpcyBpcyBzZW50IGludG8gdGhlIERPTSBwYXJ0IG9mIHRoZSBhcHAgYXQgZGlkLWZpbmlzaCBsb2FkOyBzZWUgYmVsb3cuXG5jb25zdCBoYWlrdSA9IGdsb2JhbC5wcm9jZXNzLmVudi5IQUlLVV9FTlZcbiAgPyBKU09OLnBhcnNlKGdsb2JhbC5wcm9jZXNzLmVudi5IQUlLVV9FTlYpXG4gIDoge31cblxuaWYgKCFoYWlrdS5mb2xkZXIpIHtcbiAgaGFpa3UuZm9sZGVyID0gZ2xvYmFsLnByb2Nlc3MuZW52LkhBSUtVX1BST0pFQ1RfRk9MREVSXG59XG5cbmxldCBicm93c2VyV2luZG93ID0gbnVsbFxuXG5hcHAub24oJ3dpbmRvdy1hbGwtY2xvc2VkJywgKCkgPT4ge1xuICBhcHAucXVpdCgpXG59KVxuXG5pZiAoIWhhaWt1LnBsdW1iaW5nKSBoYWlrdS5wbHVtYmluZyA9IHt9XG5cbmlmICghaGFpa3UucGx1bWJpbmcudXJsKSB7XG4gIGlmIChnbG9iYWwucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJiAhZ2xvYmFsLnByb2Nlc3MuZW52LkhBSUtVX1BMVU1CSU5HX1BPUlQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYE9vcHMhIFlvdSBtdXN0IGRlZmluZSBhIEhBSUtVX1BMVU1CSU5HX1BPUlQgZW52IHZhciFgKVxuICB9XG5cbiAgaGFpa3UucGx1bWJpbmcudXJsID0gYGh0dHA6Ly8ke2dsb2JhbC5wcm9jZXNzLmVudi5IQUlLVV9QTFVNQklOR19IT1NUIHx8ICcwLjAuMC4wJ306JHtnbG9iYWwucHJvY2Vzcy5lbnYuSEFJS1VfUExVTUJJTkdfUE9SVH0vYFxufVxuXG5mdW5jdGlvbiBkaWZmZXJlbnQgKGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IGJcbn1cblxuZnVuY3Rpb24gY3JlYXRlV2luZG93ICgpIHtcbiAgbWl4cGFuZWwuaGFpa3VUcmFjaygnYXBwOmluaXRpYWxpemUnKVxuXG4gIGNvbnN0IHRvcG1lbnUgPSBuZXcgVG9wTWVudSgpXG5cbiAgY29uc3QgbWVudXNwZWMgPSB7XG4gICAgdW5kb2FibGVzOiBbXSxcbiAgICByZWRvYWJsZXM6IFtdLFxuICAgIHByb2plY3RMaXN0OiBbXSxcbiAgICBpc1NhdmluZzogZmFsc2UsXG4gICAgZm9sZGVyOiBudWxsXG4gIH1cblxuICB0b3BtZW51LmNyZWF0ZShtZW51c3BlYylcblxuICBpcGNNYWluLm9uKCdtYXN0ZXI6aGVhcnRiZWF0JywgKGlwY0V2ZW50LCBtYXN0ZXJTdGF0ZSkgPT4ge1xuICAgIC8vIFVwZGF0ZSB0aGUgZ2xvYmFsIG1lbnUsIGJ1dCBvbmx5IGlmIHRoZSBkYXRhIGZlZWRpbmcgaXQgYXBwZWFycyB0byBoYXZlIGNoYW5nZWQuXG4gICAgLy8gVGhpcyBpcyBkcml2ZW4gYnkgYSBmcmVxdWVudCBoZWFydGJlYXQgaGVuY2UgdGhlIHJlYXNvbiB3ZSBhcmUgY2hlY2tpbmcgZm9yIGNoYW5nZXNcbiAgICAvLyBiZWZvcmUgYWN0dWFsbHkgcmUtcmVuZGVyaW5nIHRoZSB3aG9sZSB0aGluZ1xuICAgIGxldCBkaWRDaGFuZ2UgPSBmYWxzZVxuXG4gICAgLy8gVGhlIHJlYXNvbiBmb3IgYWxsIHRoZXNlIGd1YXJkcyBpcyB0aGF0IGl0IGFwcGVhcnMgdGhhdCB0aGUgaGVhcnRiZWF0IGVpdGhlclxuICAgIC8vIChhKSBjb250aW51ZXMgdG8gdGljayBkZXNwaXRlIG1hc3RlciBjcmFzaGluZ1xuICAgIC8vIChiKSByZXR1cm5zIGJhZCBkYXRhLCBtaXNzaW5nIHNvbWUgZmllbGRzLCB3aGVuIG1hc3RlciBpcyBpbiBhIGJhZCBzdGF0ZVxuICAgIC8vIFNvIHdlIGNoZWNrIHRoYXQgdGhlIHRoaW5ncyBleGlzdCBiZWZvcmUgcmVwb3B1bGF0aW5nXG4gICAgaWYgKG1hc3RlclN0YXRlKSB7XG4gICAgICBpZiAobWFzdGVyU3RhdGUuZ2l0VW5kb2FibGVzKSB7XG4gICAgICAgIGlmIChkaWZmZXJlbnQobWVudXNwZWMudW5kb2FibGVzLmxlbmd0aCwgbWFzdGVyU3RhdGUuZ2l0VW5kb2FibGVzLmxlbmd0aCkpIHtcbiAgICAgICAgICBkaWRDaGFuZ2UgPSB0cnVlXG4gICAgICAgICAgbWVudXNwZWMudW5kb2FibGVzID0gbWFzdGVyU3RhdGUuZ2l0VW5kb2FibGVzIHx8IFtdXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hc3RlclN0YXRlLmdpdFJlZG9hYmxlcykge1xuICAgICAgICBpZiAoZGlmZmVyZW50KG1lbnVzcGVjLnJlZG9hYmxlcy5sZW5ndGgsIG1hc3RlclN0YXRlLmdpdFJlZG9hYmxlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgZGlkQ2hhbmdlID0gdHJ1ZVxuICAgICAgICAgIG1lbnVzcGVjLnJlZG9hYmxlcyA9IG1hc3RlclN0YXRlLmdpdFJlZG9hYmxlcyB8fCBbXVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmZXJlbnQobWVudXNwZWMuZm9sZGVyLCBtYXN0ZXJTdGF0ZS5mb2xkZXIpKSB7XG4gICAgICAgIGRpZENoYW5nZSA9IHRydWVcbiAgICAgICAgbWVudXNwZWMuZm9sZGVyID0gbWFzdGVyU3RhdGUuZm9sZGVyXG4gICAgICB9XG5cbiAgICAgIGlmIChkaWZmZXJlbnQobWVudXNwZWMuaXNTYXZpbmcsIG1hc3RlclN0YXRlLmlzU2F2aW5nKSkge1xuICAgICAgICBkaWRDaGFuZ2UgPSB0cnVlXG4gICAgICAgIG1lbnVzcGVjLmlzU2F2aW5nID0gbWFzdGVyU3RhdGUuaXNTYXZpbmdcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgICB0b3BtZW51LmNyZWF0ZShtZW51c3BlYylcbiAgICB9XG4gIH0pXG5cbiAgaXBjTWFpbi5vbigncmVuZGVyZXI6cHJvamVjdHMtbGlzdC1mZXRjaGVkJywgKGlwY0V2ZW50LCBwcm9qZWN0TGlzdCkgPT4ge1xuICAgIG1lbnVzcGVjLnByb2plY3RMaXN0ID0gcHJvamVjdExpc3RcbiAgICB0b3BtZW51LmNyZWF0ZShtZW51c3BlYylcbiAgfSlcblxuICBicm93c2VyV2luZG93ID0gbmV3IEJyb3dzZXJXaW5kb3coe1xuICAgIHRpdGxlOiAnSGFpa3UnLFxuICAgIHNob3c6IGZhbHNlLCAvLyBEb24ndCBzaG93IHRoZSB3aW5kb3cgdW50aWwgd2UgYXJlIHJlYWR5LXRvLXNob3cgKHNlZSBiZWxvdylcbiAgICB0aXRsZUJhclN0eWxlOiAnaGlkZGVuLWluc2V0JyxcbiAgICB3ZWJQcmVmZXJlbmNlczoge1xuICAgICAgd2ViU2VjdXJpdHk6IGZhbHNlXG4gICAgfVxuICB9KVxuXG4gIGJyb3dzZXJXaW5kb3cuc2V0VGl0bGUoJ0hhaWt1JylcbiAgYnJvd3NlcldpbmRvdy5tYXhpbWl6ZSgpXG4gIGJyb3dzZXJXaW5kb3cubG9hZFVSTChhcHBVcmwpXG5cbiAgLy8gU2VuZGluZyBvdXIgaGFpa3UgY29uZmlndXJhdGlvbiBpbnRvIHRoZSB2aWV3IHNvIGl0IGNhbiBjb3JyZWN0bHkgc2V0IHVwXG4gIC8vIGl0cyBvd24gd2Vic29ja2V0IGNvbm5lY3Rpb25zIHRvIG91ciBwbHVtYmluZyBzZXJ2ZXIsIGV0Yy5cbiAgYnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5vbignZGlkLWZpbmlzaC1sb2FkJywgKCkgPT4ge1xuICAgIGJyb3dzZXJXaW5kb3cud2ViQ29udGVudHMuc2VuZCgnaGFpa3UnLCBoYWlrdSlcbiAgfSlcblxuICAvLyBUb3BNZW51IGdsb2JhbC1tZW51Oi1wcmVmaXhlZCBldmVudHMgc2hvdWxkIGRlbGVnYXRlIHRvIEJyb3dzZXJXaW5kb3cgZm9yIGV2ZW50IGhhbmRsZXJzLlxuICBjb25zdCBnbG9iYWxNZW51UGFzc3Rocm91Z2hzID0gW1xuICAgICdjaGVjay11cGRhdGVzJyxcbiAgICAnZXhwb3J0JyxcbiAgICAnb3Blbi10ZXJtaW5hbCcsXG4gICAgJ29wZW4tdGV4dC1lZGl0b3InLFxuICAgICdyZWRvJyxcbiAgICAnc2F2ZScsXG4gICAgJ3N0YXJ0LXRvdXInLFxuICAgICd0b2dnbGUtZGV2LXRvb2xzJyxcbiAgICAndW5kbycsXG4gICAgJ3pvb20taW4nLFxuICAgICd6b29tLW91dCcsXG4gICAgLy8gQWN0aXZlIGluIGRldiAmIHN0YWdpbmcgb25seS5cbiAgICAnZHVtcC1zeXN0ZW0taW5mbycsXG4gICAgJ29wZW4taGFja2VyLWhlbHBlcidcbiAgXVxuXG4gIGdsb2JhbE1lbnVQYXNzdGhyb3VnaHMuZm9yRWFjaCgoY29tbWFuZCkgPT4ge1xuICAgIHRvcG1lbnUub24oYGdsb2JhbC1tZW51OiR7Y29tbWFuZH1gLCAoLi4uYXJncykgPT4ge1xuICAgICAgYnJvd3NlcldpbmRvdy53ZWJDb250ZW50cy5zZW5kKGBnbG9iYWwtbWVudToke2NvbW1hbmR9YCwgLi4uYXJncylcbiAgICB9KVxuICB9KVxuXG4gIGJyb3dzZXJXaW5kb3cub24oJ2Nsb3NlZCcsICgpID0+IHsgYnJvd3NlcldpbmRvdyA9IG51bGwgfSlcblxuICBicm93c2VyV2luZG93Lm9uKCdyZWFkeS10by1zaG93JywgKCkgPT4ge1xuICAgIGJyb3dzZXJXaW5kb3cuc2hvdygpXG4gIH0pXG5cbiAgLy8gVW5jb21tZW50IG1lIHRvIGF1dG9tYXRpY2FsbHkgb3BlbiB0aGUgdG9vbHNcbiAgLy8gYnJvd3NlcldpbmRvdy5vcGVuRGV2VG9vbHMoKVxufVxuXG5pZiAoYXBwLmlzUmVhZHkoKSkge1xuICBjcmVhdGVXaW5kb3coKVxufSBlbHNlIHtcbiAgYXBwLm9uKCdyZWFkeScsIGNyZWF0ZVdpbmRvdylcbn1cblxuLy8gSGFja3k6IFdoZW4gcGx1bWJpbmcgbGF1bmNoZXMgaW5zaWRlIGFuIEVsZWN0cm9uIHByb2Nlc3MgaXQgZXhwZWN0cyBhbiBFdmVudEVtaXR0ZXItbGlrZVxuLy8gb2JqZWN0IGFzIHRoZSBleHBvcnQsIHNvIHdlIGV4cG9zZSB0aGlzIGhlcmUgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBkbyBtdWNoXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmYXVsdDogY3JlYXRvclxufVxuIl19
{"version":3,"sources":["../src/MasterModuleProject.js"],"names":["QUEUE_INTERVAL","LAST_WRITE_MARGIN_OF_ERROR_MILLISECONDS","MasterModuleProject","folder","proc","Error","_pendingReloads","_modificationsQueue","_modificationsInterval","setInterval","moduleMods","splice","length","maybeSendComponentReloadRequest","file","isOpen","lastRead","get","lastWrite","emit","push","socket","send","type","name","relpath","message","from","shift"],"mappings":";;;;;;;;AAAA;;;;;;;;AAEA,IAAMA,iBAAiB,EAAvB;AACA,IAAMC,0CAA0C,GAAhD;;IAEqBC,mB;;;AACnB,+BAAaC,MAAb,EAAqBC,IAArB,EAA2B;AAAA;;AAAA;;AAGzB,UAAKD,MAAL,GAAcA,MAAd,CAHyB,CAGJ;;AAErB,QAAI,CAAC,MAAKA,MAAV,EAAkB;AAChB,YAAM,IAAIE,KAAJ,CAAU,4EAAV,CAAN;AACD;;AAED,UAAKD,IAAL,GAAYA,IAAZ,CATyB,CASR;;AAEjB;AACA,UAAKE,eAAL,GAAuB,EAAvB;;AAEA;AACA,UAAKC,mBAAL,GAA2B,EAA3B;;AAEA;AACA;AACA;AACA,UAAKC,sBAAL,GAA8BC,YAAY,YAAM;AAC9C,UAAMC,aAAa,MAAKH,mBAAL,CAAyBI,MAAzB,CAAgC,CAAhC,CAAnB;AACA,UAAID,WAAWE,MAAX,GAAoB,CAAxB,EAA2B,OAAO,KAAM,CAAb;AAC3B,YAAKC,+BAAL,CAAqCH,WAAWA,WAAWE,MAAX,GAAoB,CAA/B,CAArC;AACD,KAJ6B,EAI3BZ,cAJ2B,CAA9B;AApByB;AAyB1B;;;;8BAEU;AACT;AACA;AACA,WAAKO,mBAAL,CAAyBI,MAAzB,CAAgC,CAAhC;AACA,WAAKL,eAAL,CAAqBK,MAArB,CAA4B,CAA5B;AACD;;;oDAEgCG,I,EAAM;AACrC,UAAI,CAAC,KAAKV,IAAL,CAAUW,MAAV,EAAL,EAAyB,OAAO,KAAM,CAAb;;AAEzB;AACA;AACA,UAAMC,WAAWF,KAAKG,GAAL,CAAS,iBAAT,CAAjB;AACA,UAAMC,YAAYJ,KAAKG,GAAL,CAAS,kBAAT,IAA+BhB,uCAAjD;AACA,UAAIe,WAAWE,SAAf,EAA0B,OAAO,KAAM,CAAb;;AAE1B,WAAKC,IAAL,CAAU,mBAAV,EAA+BL,IAA/B;;AAEA;AACA;AACA;AACA,WAAKR,eAAL,CAAqBc,IAArB,CAA0BN,IAA1B;;AAEA,WAAKV,IAAL,CAAUiB,MAAV,CAAiBC,IAAjB,CAAsB;AACpBC,cAAM,WADc;AAEpBC,cAAM,kBAFc;AAGpBC,iBAASX,KAAKG,GAAL,CAAS,SAAT;AAHW,OAAtB;AAKD;;;yCAEqBS,O,EAAS;AAC7B;AACA;AACA,UAAIA,QAAQC,IAAR,KAAiB,OAArB,EAA8B;AAC5B,aAAKR,IAAL,CAAU,iBAAV,EAA6B,KAAKb,eAAL,CAAqBsB,KAArB,EAA7B;AACD;AACF;;;uCAEmBd,I,EAAM;AACxB,WAAKP,mBAAL,CAAyBa,IAAzB,CAA8BN,IAA9B;AACD;;;;;;kBApEkBZ,mB","file":"MasterModuleProject.js","sourcesContent":["import { EventEmitter } from 'events'\n\nconst QUEUE_INTERVAL = 64\nconst LAST_WRITE_MARGIN_OF_ERROR_MILLISECONDS = 500\n\nexport default class MasterModuleProject extends EventEmitter {\n  constructor (folder, proc) {\n    super()\n\n    this.folder = folder // String\n\n    if (!this.folder) {\n      throw new Error('[master-module] MasterModuleProject cannot launch without a folder defined')\n    }\n\n    this.proc = proc // ProcessBase\n\n    // Reloads that we've requested that have not finished yet\n    this._pendingReloads = []\n\n    // A queue of incoming module modifications that we've detected\n    this._modificationsQueue = []\n\n    // Since a lot of changes can happen at the same time, we want to avoid accidentally\n    // triggering a whole bunch of reloads, hence this queue, which has an opportunity to combine them or just\n    // handle sequential reloads a bit more gracefully.\n    this._modificationsInterval = setInterval(() => {\n      const moduleMods = this._modificationsQueue.splice(0)\n      if (moduleMods.length < 1) return void (0)\n      this.maybeSendComponentReloadRequest(moduleMods[moduleMods.length - 1])\n    }, QUEUE_INTERVAL)\n  }\n\n  restart () {\n    // Remove anything pending we have in the queues to avoid any mistaken\n    // reloads that may still be pending in case the window was refreshed.\n    this._modificationsQueue.splice(0)\n    this._pendingReloads.splice(0)\n  }\n\n  maybeSendComponentReloadRequest (file) {\n    if (!this.proc.isOpen()) return void (0)\n\n    // If the last time we read from the file system came after the last time we wrote to it,\n    // that's a decent indication that the last known change occurred directly on the file system.\n    const lastRead = file.get('dtLastReadStart')\n    const lastWrite = file.get('dtLastWriteStart') + LAST_WRITE_MARGIN_OF_ERROR_MILLISECONDS\n    if (lastRead < lastWrite) return void (0)\n\n    this.emit('triggering-reload', file)\n\n    // This is currently only used to detect whether we are in the midst of reloading so\n    // that the master undo/redo queue can be smarter about whether to activate or not.\n    // TODO: This smartness has not been implemented yet, please implement!\n    this._pendingReloads.push(file)\n\n    this.proc.socket.send({\n      type: 'broadcast',\n      name: 'component:reload',\n      relpath: file.get('relpath')\n    })\n  }\n\n  handleReloadComplete (message) {\n    // We remove a pending reload only if the glass told us it completed a reload,\n    // since that is the place it counts (and we only want to do this once per reload).\n    if (message.from === 'glass') {\n      this.emit('reload-complete', this._pendingReloads.shift())\n    }\n  }\n\n  handleModuleChange (file) {\n    this._modificationsQueue.push(file)\n  }\n}\n"]}